import {
    GameResult,
    GameState,
    HydratableGameState,
    HydratedTurnManager,
    PrngState
} from '@tabletop/common'
import { {{properCase game}}PlayerState, Hydrated{{properCase game}}PlayerState } from './playerState.js'
import * as Type from 'typebox'
import { Compile } from 'typebox/compile'
import { MachineState } from '../definition/states.js'

export type {{properCase game}}GameState = Type.Static<typeof {{properCase game}}GameState>
export const {{properCase game}}GameState = Type.Evaluate(
    Type.Intersect([
        Type.Omit(GameState, ['players', 'machineState']),
        Type.Object({
            players: Type.Array({{properCase game}}PlayerState), // Redefine with the specific player state type
            machineState: Type.Enum(MachineState), // Redefine with the specific machine states
        })
    ])
)

const {{properCase game}}GameStateValidator = Compile({{properCase game}}GameState)

export class Hydrated{{properCase game}}GameState
    extends HydratableGameState<typeof {{properCase game}}GameState, Hydrated{{properCase game}}PlayerState>
    implements {{properCase game}}GameState
{
    // Declare properties to satisfy the interface, they will be populated by the base class
    declare id: string
    declare gameId: string
    declare prng: PrngState
    declare activePlayerIds: string[]
    declare actionCount: number
    declare actionChecksum: number
    declare players: Hydrated{{properCase game}}PlayerState[]
    declare turnManager: HydratedTurnManager
    declare machineState: MachineState
    declare result?: GameResult
    declare winningPlayerIds: string[]

    constructor(data: {{properCase game}}GameState) {
        super(data, {{properCase game}}GameStateValidator)

        this.players = data.players.map((player) => new Hydrated{{properCase game}}PlayerState(player))
    }
}
